var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Welcome to Internal Technical Documentation","text":"<p>This site contains documentation for our internal systems, covering both software and infrastructure design.  This documentation is aimed at software and/or devops engineers.</p>"},{"location":"index.html#sections","title":"Sections","text":"<ul> <li>Software Design: Information about the architecture and design of our software components.</li> <li>Infrastructure Design: Details on our infrastructure setup, e.g. CI/CD, hostnames, and database access.</li> </ul> <p>Please use the navigation bar to explore the different sections.</p>"},{"location":"infrastructure-design/index.html","title":"Infrastructure Design Overview","text":"<p>This section provides details about our infrastructure - where it is and how to use it.</p>"},{"location":"infrastructure-design/architecture.html","title":"Overall Infrastructure Architecture","text":"<p>Our infrastructure is hosted on Digital Ocean as much as possible, with some exceptions.</p>"},{"location":"infrastructure-design/architecture.html#digital-ocean-services","title":"Digital Ocean Services","text":"<ul> <li>App Platform: Both the frontend and backend codebases are deployed using digital ocean app platform. This is a serverless infrastructure solution that    takes a containerized application/codebase in a popular framework and manages hosting it.</li> <li>Postgres Database: The API has a postgres dependency. We use a managed digital ocean postgres database for this.</li> <li>Firewalls: These are all configured through the default digital ocean settings.</li> <li>DNS: These are configured through digital ocean networking settings.</li> <li>Image registry: The API can only be deployed via a custom image - app platform has no out of the box integrations for rust apps - so we use a    digital ocean image registry for this.</li> </ul>"},{"location":"infrastructure-design/architecture.html#elestio-hostname","title":"Elestio Hostname","text":"<p>The <code>sudandigitalarchive.com</code> hostname is purchased from elestio as hangover of trialing use of  bayanat for the archive.</p> <p>Note that the CNAME and other records are not managed here - these are done from within digital ocean.</p>"},{"location":"infrastructure-design/architecture.html#environments","title":"Environments","text":"<p>Note that we currently only have a production environment. There is no dev/staging environment in order to keep costs down.  There are instructions in each of the repos on how to do development on your local machine, which is probably going to be the way forward for a while unless we get much money.</p>"},{"location":"infrastructure-design/ci-cd.html","title":"CI/CD","text":"<p>The frontend and backend both use Github actions for CI/CD. </p>"},{"location":"infrastructure-design/ci-cd.html#frontend","title":"Frontend","text":"<p>This one is very managed - Digital Ocean app platform has a built in integration for react apps, so when a new commit is added to this repo it automatically deploys a new version of the site.</p>"},{"location":"infrastructure-design/ci-cd.html#backend","title":"Backend","text":"<p>This one is different since app platform has no out of the box integration for Rust/Axum apps. Instead, the pipeline builds a new container image and uploads the new image to the digital ocean registry.</p> <p>This then triggers a new deployment of the API - i.e. deployment fires whenever the API image tag is bumped.</p>"},{"location":"infrastructure-design/database-access.html","title":"Accessing the Database","text":"<p>Access to the production database is restricted to the API application only.</p> <p>If you need to make changes to it, then within digital ocean you need to temporarily whitelist your current IP address and connect.</p>"},{"location":"software-design/index.html","title":"Software Design Overview","text":"<p>The below diagram details the overall system architecture:</p> <p></p> <p>Note that this flow is for what happens when a logged in user queries data and triggers a crawl, since this illustrates all the components in the stack.</p>"},{"location":"software-design/index.html#components","title":"Components","text":"<ul> <li>The frontend codebase</li> <li>The API codebase. Note there   is a full Open API spec available on the Swagger site    here.</li> <li>Browsertrix API refers to browsertrix. You can see their swagger API docs    here</li> <li>Postmark API refers to postmark</li> <li>The frontend, API, and postgres database all live on digital ocean. See the infrastructure section for more information</li> </ul>"},{"location":"software-design/index.html#data-modelling","title":"Data Modelling","text":"<p>See the entity relation diagrams here. These describe what is in the postgres database</p>"},{"location":"software-design/entity_relation_diagrams.html","title":"Entity Relation Diagrams","text":"<p>This section contains autogenerated entity relationship diagrams  for the schemas in the postgres database.</p> <p>To generate these schema, I used dbeaver and then stitched the different schema together in canva.  You can follow the installation instructions  here.</p>"},{"location":"software-design/entity_relation_diagrams.html#tables","title":"Tables","text":"<p>This section denotes the tables where the data is stored. In practice most queries hit a view since that makes it easier to work with all the relationships in the data.</p> <p></p>"},{"location":"software-design/entity_relation_diagrams.html#views","title":"Views","text":"<p>This logical view combines the accessions with various associated metadata.</p> <p></p>"}]}